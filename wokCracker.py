# WRITTEN DECEMBER 3, 2024, BY J. JEHOVAHKIN
# FORKED FROM THE CODE I WROTE FOR MY KEYPAD TO FUNCTION, ITSELF FORKED FROM CODE FROM SOME WEBSITE SOMEWHERE
# THE HUNGER BURNS WITHIN MY GUT
import RPi.GPIO as GPIO
import time

GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)

# ROWS:

L1 = 5
L2 = 6
L3 = 13
L4 = 19

LINES = [5, 6, 13, 19]

# WE'VE GOTTA INVERT THESE SUCKERS. OUTPUT BECOMES INPUT!

GPIO.setup(L1, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(L2, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(L3, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(L4, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

# COLUMNS:

C4 = 1
C3 = 7
C2 = 8
C1 = 25

COLUMNS = [25, 8, 7, 1]

GPIO.setup(C1, GPIO.OUT)
GPIO.setup(C2, GPIO.OUT)
GPIO.setup(C3, GPIO.OUT)
GPIO.setup(C4, GPIO.OUT)

# NOT GONNA MESS WITH ALL THE LOGGING STUFF HERE... MAYBE LATER
# TODO: IMPLEMENT LOGGING

# TIME TO FIGURE OUT OUR FUNCTIONS...

# OKAY, HERE'S THE DEAL. FIRST, WE HAVE TO SYNCHRONIZE WITH THE TIMING OF THE LINE SENDS ON THE TARGET.
synchronized = False

while not synchronized:
	if (GPIO.input(L1) == 1):
		synchronized = True
		print("SYNCHRONIZED, CAUGHT INPUT ON LINE 1")
	else:
		time.sleep(0.01)

# NOW WE'RE SET TO START SENDING OUR INPUT!
currentInput = 0 # FOR THIS PROTOTYPE, WE'RE JUST GONNA START BY RUNNING EVERY NUMBER FROM 0 to 1000

# while currentInput < 1000:
	
